

definitions:
s2c = server to client
c2s = client to server
c2c = client to client


how to save bandwidth and reduce lag: have clients send position packets
to each other.

what needs to be worked out?
	what will be sent?
	who will send it?
	to whom?
	what about firewalled clients?
	how will this be secure?


what:

only unreliable traffic goes c2c. specifically, only position and
weapons packets.

who:

all players (using continuum 0.xx and above)

to whom:

for any given position or weapon packet, the client should calculate
which players need to receive it (including the players on radar that
don't get every packet). call that S1. of S1, the client should figure
out who can receive the packet c2c, the set S2. this will be the
original set, minus players using a too-old client version, minus
firewalled players. order S2 by priority and select the highest
(bwlim/10/(len+overhead) - 1), that set is S3. (typical values suggest
that expression's value will be around 8-15). send the packet to each of
those players, and also send the packet to the server. the packet to the
server will contain the player ids of S3 (so the server knows not to
send to them).

firewalls:

the server will know when a client is using a client that doesn't
support c2c packets. it can also know when a client is firewalled, by
sending a query packet from another port on the server to the game port
on the client. if the client replies to the query packet, it knows it
can recieve packets from arbitrary addresses. of course, this packet
will have to be re-sent up to n times if it isn't replied to, so that
packetloss won't affect this determination. to indicate to other clients
whether a particular client is capable of receiving c2c data, there will
be an extra 6 bytes in the player info packet for someone's ip address
and port. these bytes will be zero if the player can't receive c2c data.

security:

this is the tricky part.

here's what we have to work with: each cont client contains a keystream
generator that can generate a keystream from an arbitrary key and
scramble it with another arbitrary key. when a client connects to the
server, the server gives it the two keys used to encrypt all traffic.

we need two clients to be able to agree on a (or two) keys to use
without any prior communication. the server doesn't need to know the
keys or keystreams used for c2c data. having a separate keystream for
each other client is acceptable, since it's only 80 bytes. initializing
the keystream for each incoming player might not be acceptable.

#ifdef DISCARDED_IDEAS

idea 1: apply some standard transformation (1's complement and swap
order) to the two server keys to obtain the client keys. won't work
unless the server uses the same key for all clients, which is impossible
without having it use the same key indefinitely, which is a bad idea.

idea 1a: obtain the c2c key from the server key with a transformation,
but extend the protocol to support rekeying without disconnection. to do
this, the server sends a 00 10 yy yy yy yy zz zz zz zz ww ww, with w = 2
and the client confirms with 0x11 yy yy yy yy ww ww. if all udp data
from s2c and c2s is ordered, the rekeying will lose no data. if some
packets are out of order, they will be lost. it gets more complicated
when c2c data is added: I think some c2c data will almost certainly be
lost during a rekey, which isn't optimal.

#endif

idea 2: what constant does each client know about each other? the pid,
name, squad, ip, and port. I want something that changes relatively
often, but not during a "game session" (time spent in one arena). so
I'll make something: put a new field in playerdata which will be a
random key generated by the server. use that key to generate a keystream
to use for all outgoing c2c packets. for each player, use the key in the
playerdata to generate a keystream to use for incoming c2c packets from
that player.

this means each outgoing packet has to be encrypted only once to send to
n players, and once more to the server. and of course each incoming
packet has to be decrypted once.

the client gets player info packets on everyone entering the arena
before it enters the game, so it can delay entering the game until it's
generated keystreams for each of them. it also must generate a keystream
for each player who enters, and one for itself upon entering an arena,
which hopefully won't take long.

possible attacks:

each packet has a crc, also encrypted, so anyone randomly modifying
bytes of outgoing c2c data will have their packets dropped by the
recving clients.

in order to modify the data of a c2c packet correctly, an attacker would
have to obtain the keystream used to send it. this keystream changes
each time someone enters an arena. and the keystream generator is
relatively hard to extract from cont.exe. so knowledgably modifying c2c
data is just as hard as doing it to c2s data.

lag:

what about configuring a firewall or router to drop all or most c2c
packets, either incoming or outgoing?

if lots of outgoing packets are lost, some other players would see the
cheating client as being extremely jumpy, but others (probably the ones
slightly further away, plus all the spectators) would see him normally
(assuming he doesn't modify the c2s stream). this would be easy to
detect by a human, but what about by the server?

if lots of incoming packets are lost, this client will lose information
about other clients, including not seeing some of their weapons, and
they will appear jumpy.

how do we detect these? each client should keep track, for each other
client in the arena, how many c2c packets it has sent and received
to/from that client. when the server requests it, the client will send a
summary of this information, and then reset the counts until the next
request.

using the packet counts gathered from all players, the server can
calculate c2o and o2c ploss percentages in O(n) memory (but roughly
O(n^2) time) by calculating total sent to, received by, sent from, and
received from, each player.



protocol modifications:

s2c player info:

struct PlayerData
{
	// ... other stuff ...
	i16 flagscarried;
	u8 miscbits;
	// added fields (10 bytes):
	u32 ipaddy; // zero if no c2c packets
	u16 port;   // ''
	u32 randomkey; // used for encryption
}


c2c postion/weapons (this is a new packet type):

struct C2CPosition /* 17 bytes */
{
	u8 type; /* 0x53 */
	i8 rotation;
	u16 time;
	i16 x;
	i16 y;
	i16 xspeed;
	i16 yspeed;
	i8 status;
	struct Weapons weapon; // optional, missing == no weapon
	u16 bounty; // optional, missing == use last bounty value
};

/* you don't need a pid because you will know the ip address and port
 * the packet came from, and each client will maintain a mapping from
 * ip/port to pid. */


c2s position:

struct C2SPosition
{
	u8 type; /* 0x03 */
	i8 rotation;
	u32 time;
	i16 xspeed;
	i16 y;
	i8 checksum;
	i8 status;
	i16 x;
	i16 yspeed;
	u16 bounty;
	i16 energy;
	struct Weapons weapon;
	struct ExtraPosData extra;
	// see below
	u8 pidset[0];
};

/* the format of the pidset field is as follows:
 * it's a series of variable-length pids, encoded as follows: if the pid
 * is between 0 and 127, it's encoded as a single byte. if it's 128 or
 * greater, it's encoded as two bytes: the first one with the lower 7
 * bits of the pid or'd with 0x80, and the second with the upper 8 bits
 * of the pid. this can represent any pid up to 32767. the server should
 * calculate the players to send this packet to, as before, but it
 * should not send the packet to the players on this list.
 */


c2c ploss report:

server sends one-byte reliable packet S2C_REQUEST_C2C_PLOSS_REPORT when
it wants updated c2c ploss data.
the client should send this reliably:

struct C2SC2CPLossReport
{
	u8 type; /* C2S_C2C_PLOSS_REPORT */
	struct
	{
		i16 pid;
		u16 sent, recvd;
	} entry[0]; // any number of these
	// each entry (there should be one for each player in the arena that
	// this client has either sent or recvd c2c data from/to) contains a
	// pid and the number of c2c packets sent and recvd from that player
	// SINCE THE LAST REPORT. if this packet ends up longer than the
	// maximum packet size, it should be sent with 00 08/9s.
};


c2s security warning:

(fill this in later. the idea is that if a client gets a c2c packet with
a bad checksum, it reports the pid it came from to the server.)


out of band firewall test:

struct FirewallTest
{
	u8 type; /* S2C_FIREWALL_TEST */
	u32 data;
};

server sends one of these from a port other than its main port to the
client's port. client should respond with the same packet back to the
port it came from (the non-main one).


